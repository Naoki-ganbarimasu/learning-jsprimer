# データ型とリテラル

## typeof演算子

```javascript
console.log(typeof true); // => "boolean"
console.log(typeof 42); // => "number"
console.log(typeof 9007199254740992n); // => "bigint"
console.log(typeof "JavaScript"); // => "string"
console.log(typeof Symbol("シンボル")); // => "symbol"
console.log(typeof undefined); // => "undefined"
console.log(typeof null); // => "object"
console.log(typeof ["配列"]); // => "object"
console.log(typeof { "key": "value" }); // => "object"
console.log(typeof function() {}); // => "function"
```

### シンボルってなん？

- シンボルはES2015で追加されたプリミティブ型の一つ。
- シンボルは一意で不変な値を表すために使われる。
- シンボルは、オブジェクトのプロパティキーとして使われることが多い。
- シンボルは、`Symbol`関数を使って生成する。らしい

---

## 整数リテラル

整数リテラルには次の4種類がある。

- **10進数**: 数字の組み合わせ  
  ただし、複数の数字を組み合わせた際に、先頭を0から開始すると8進数として扱われる場合がある  
  **例**: `0`, `2`, `10`

- **2進数**: `0b`（または`0B`）の後ろに、0または1の数字の組み合わせ  
  **例**: `0b0`, `0b10`, `0b1010`

- **8進数**: `0o`（または`0O`）の後ろに、0から7までの数字の組み合わせ  
  `0o`は数字のゼロと小文字アルファベットの`o`  
  **例**: `0o644`, `0o777`

- **16進数**: `0x`（または`0X`）の後ろに、0から9までの数字と`a`から`f`または`A`から`F`のアルファベットの組み合わせ  
  アルファベットの大文字・小文字の違いは値には影響しません  
  **例**: `0x30A2`, `0xEEFF`

---

`e`は指数（exponent）を意味する記号で、`e`のあとには指数部の値を書ける。たとえば、`2e8`は`2×10の8乗`となるので、10進数で表すと`200000000`となる。

```javascript
console.log(2e8); // => 200000000
```

// 2e8は2×10の8乗となるので、10進数で表すと200,000,000となります。
// 2×10の8乗が気に食わない。でも2**3が2の3乗だからなー

---

## [ES2020] BigInt

```javascript
console.log(Number.MAX_SAFE_INTEGER); // => 9007199254740991
```

これが一番大きな数字

整数の場合、数字の後ろに`n`をつけると`BigInt`型になる

```javascript
console.log(1n); // => 1n
// 2^53-1より大きな値も扱える
console.log(9007199254740992n); // => 9007199254740992n
```

---

## ダブルクォートとシングルクォート

`"`（ダブルクォート）と`'`（シングルクォート）はまったく同じ意味だが、以下のように同じ記号が出た場合は`\`を使いエスケープしないといけない

```javascript
'8 o\'clock'; // => "8 o'clock"
```

ダブルクォートとシングルクォートどちらも、改行をそのままでは入力できない。以下のように改行を含んだ文字列は定義できないため、構文エラー（`SyntaxError`）となる。

```javascript
"複数行の
文字列を
入れたい";
```

// => SyntaxError: "" string literal contains an unescaped line break

上記のエラーを回避するために`\n`を使う

```javascript
"複数行の\n文字列を\n入れたい";
```

また、`\``（バッククォート）を使うと改行をそのまま入力できる

```javascript
`複数行の
文字列を
入れたい`; // => "複数行の\n文字列を\n入れたい"
```

テンプレートリテラルも他の文字列リテラルと同様に同じリテラル記号を内包したい場合は、`\`を使ってエスケープする必要がある。

```javascript
`This is \`code\``; // => "This is `code`"
```

**感想**: 知らんかった！

---

## nullリテラルとundefined

`null`は定義されていない、`undefined`は値が代入されていない、定義はされている。

---

## オブジェクトリテラル

JavaScriptにおいて、オブジェクトはあらゆるものの基礎となる。そのオブジェクトを作成する方法として、オブジェクトリテラルがある。オブジェクトリテラルは`{ }`（中カッコ）を書くことで、新しいオブジェクトを作成できる。

```javascript
const obj = {
    key: "value"
};
```

- **ドット記法**

  ```javascript
  console.log(obj.key); // => "value"
  ```

- **ブラケット記法**

  ```javascript
  console.log(obj["key"]); // => "value"
  ```

---

## 配列リテラル

オブジェクトリテラルと並んで、よく使われるリテラルとして配列リテラルがあります。配列リテラルは`[`と`]`で値をカンマ区切りで囲み、その値を持つ`Array`オブジェクトを作成します。配列（`Array`オブジェクト）とは、複数の値に順序をつけて格納できるオブジェクトの一種です。

```javascript
const emptyArray = []; // 空の配列を作成
const array = [1, 2, 3]; // 値を持った配列を作成
```

配列は0からはじまるインデックス（添字）に、対応した値を保持している。作成した配列の要素を取得するには、配列に対して`array[index]`という構文で指定したインデックスの値を参照できる。

```javascript
const array = ["index:0", "index:1", "index:2"];
// 0番目の要素を参照
console.log(array[0]); // => "index:0"
// 1番目の要素を参照
console.log(array[1]); // => "index:1"
```

---

## プリミティブ型とオブジェクト

プリミティブ型は基本的にリテラルで表現する。しかし、真偽値（`Boolean`）、数値（`Number`）、文字列（`String`）はそれぞれオブジェクトとして表現する方法もある。これらはプリミティブ型の値をラップしたようなオブジェクトであるため**ラッパーオブジェクト**と呼ばれる。ラッパーオブジェクトは、`new`演算子と対応するコンストラクタ関数を利用して作成できます。たとえば、文字列のプリミティブ型に対応するコンストラクタ関数は`String`となります。

次のコードでは、`String`のラッパーオブジェクトを作成している。ラッパーオブジェクトは、名前のとおりオブジェクトの一種であるため`typeof`演算子の結果も`"object"`である。また、オブジェクトであるため`length`プロパティなどのオブジェクトが持つプロパティを参照できる。

```javascript
// 文字列をラップしたStringラッパーオブジェクト
const str = new String("文字列");
// ラッパーオブジェクトは"object"型のデータ
console.log(typeof str); // => "object"
// Stringオブジェクトの`length`プロパティは文字列の長さを返す
console.log(str.length); // => 3
```