# 演算子について

## 単項演算子（算術）

### 単項プラス演算子（+）

単項プラス演算子は、数値以外も数値へと変換します。 次のコードでは、数字（文字列）を数値へ変換しています。

```javascript
console.log(+"1"); // => 1
```

一方、数値に変換できない文字列などはNaNという特殊な値へと変換されます。

```javascript
// 数値ではない文字列はNaNという値に変換される
console.log(+"文字列"); // => NaN
```

NaNは"Not-a-Number"の略称で、数値ではないがNumber型の値をもつ。
NaNはどの値とも（NaN自身に対しても）一致しない特性があり、Number.isNaNメソッドを使うことでNaNの判定を行える。

```javascript
// 自分自身とも一致しない
console.log(NaN === NaN); // => false
// Number型である
console.log(typeof NaN); // => "number"
// Number.isNaNでNaNかどうかを判定
console.log(Number.isNaN(NaN)); // => true
```

### 単項マイナス演算子（ー）

単項マイナス演算子も同様文字列などを数値へ変換できる。

```javascript
console.log(-"1"); // => -1
```

また、数値へ変換できない文字列などをオペランドに指定した場合は、NaNという特殊な値になる
そのため、単項プラス演算子と同じく、文字列から数値への変換に単項マイナス演算子を使うべきではない。

```javascript
console.log(-"文字列"); // => NaN
```

### インクリメント演算子（++、ーー）

インクリメント演算子（++）は、オペランドの数値を+1する演算子。
オペランドの前後どちらかにインクリメント演算子を置くことで、オペランドに対して値を+1した値を返す。

```javascript
let num = 1;
num++;
console.log(num); // => 2
// 次のようにした場合と結果は同じ
// num = num + 1;
```

#### マイナスも同様

```javascript
let num = 1;
num--;
console.log(num); // => 0
// 次のようにした場合と結果は同じ
// num = num - 1;
```

インクリメント演算子（++）は、オペランドの前後どちらに置くかによって評価の順番が異なります。

後置インクリメント演算子（num++）は、次のような順で処理が行われます。

1. numの評価結果を返す
2. numに対して+1する

そのため、num++が返す値は+1する前の値となる。

```javascript
let x = 1;
console.log(x++); // => 1
console.log(x);   // => 2
```

一方、前置インクリメント演算子（++num）は、次のような順で処理が行われる。

1. numに対して+1する
2. numの評価結果を返す

そのため、++numが返す値は+1した後の値となる。

```javascript
let x = 1;
console.log(++x); // => 2
console.log(x);   // => 2
```

## 比較演算子

### 厳密等価演算子（===）

厳密等価演算子は、左右の2つのオペランドを比較する。 同じ型で同じ値である場合に、trueを返す。

```javascript
console.log(1 === 1); // => true
console.log(1 === "1"); // => false
```

また、オペランドがどちらもオブジェクトであるときは、 オブジェクトの参照が同じである場合に、trueを返す。

```javascript
// {} は新しいオブジェクトを作成している
const objA = {};
const objB = {};
// 生成されたオブジェクトは異なる参照となる
console.log(objA === objB); // => false
// 同じ参照を比較している場合
console.log(objA === objA); // => tru
```

### 等価演算子（==）

2つのオペランドを比較します。 同じデータ型のオペランドを比較する場合は、厳密等価演算子（===）と同じ結果になります。

```javascript
console.log(1 == 1); // => true
console.log("str" == "str"); // => true
console.log("JavaScript" == "ECMAScript"); // => false
// オブジェクトは参照が一致しているならtrueを返す
// {} は新しいオブジェクトを作成している
const objA = {};
const objB = {};
console.log(objA == objB); // => false
console.log(objA == objA); // => true
```

しかし、オペランド同士が異なる型の値であった場合に、 同じ型となるように暗黙的な型変換をしてから比較します。

```javascript
// 文字列を数値に変換してから比較
console.log(1 == "1"); // => true
// "01"を数値にすると`1`となる
console.log(1 == "01"); // => true
// 真偽値を数値に変換してから比較
console.log(0 == false); // => true
// nullの比較はfalseを返す
console.log(0 == null); // => false
// nullとundefinedの比較は常にtrueを返す
console.log(null == undefined); // => true
```

### 不等価演算子（!=）

これも同様に型をなおしてから比較する

## ビット演算子

ビット演算子では、オペランドである数値を符号付き32ビット整数（0と1からなる32個のビットの集合）として扱う。

たとえば、1という数値は符号付き32ビット整数のビットでは、00000000000000000000000000000001 として表現される。
わかりやすく4ビットごとに区切ると 0000_0000_0000_0000_0000_0000_0000_0001 のような32ビットの集合となる。
符号付き32ビット整数では、先頭の最上位ビット（一番左のビット）は符号を表し、0の場合は正の値、1の場合は負の値であることを示している。
逆に-1だと反転して、1111_1111_1111_1111_1111_1111_1111_1111 となる。

### ビット論理積（&）

ビット論理積演算子（&）はビットごとのAND演算した結果を返す。
AND演算では、オペランドの各ビットがどちらも1の場合は1となり、それ以外の場合は0となる。

次のコードでは、10進数の15と9をAND演算しています。
15は、符号付き32ビット整数では0000_0000_0000_0000_0000_0000_0000_1111となる。
9は、符号付き32ビット整数では0000_0000_0000_0000_0000_0000_0000_1001となる。
これらをAND演算した結果は0000_0000_0000_0000_0000_0000_0000_1001となり、
10進数の値である9を返す。

```javascript
console.log(15     & 9);      // => 9
// 同じ位の各ビット同士をAND演算する（上位の`0`は省略）
// 1111
// 1001
// ----
// 1001
console.log(0b1111 & 0b1001); // => 0b1001
```

### ビット論理和（|）

ビット論理和演算子（|）はビットごとのOR演算した結果を返す。 OR演算では、オペランドの各ビットがどちらか片方でも1の場合は1となり、両方とも0の場合は0となる。

```javascript
console.log(15     | 9);      // => 15
// 同じ位の各ビット同士をOR演算する（上位の`0`は省略）
// 1111
// 1001
// ----
// 1111
console.log(0b1111 | 0b1001); // => 0b1111
```

### ビット排他的論理和（^）

ビット排他的論理和演算子（^）はビットごとのXOR演算した結果を返します。 XOR演算では、オペランドのビットが異なるなら1、両方とも同じなら0となる。

```javascript
console.log(15     ^ 9);      // => 6
// 同じ位の各ビット同士をXOR演算する（上位の`0`は省略）
// 1111
// 1001
// ----
// 0110
console.log(0b1111 ^ 0b1001); // => 0b0110
```

### ビット否定（~）

単項演算子の否定演算子（~）はオペランドの各ビットを反転した値を返します。 これは1の補数として知られている値と同じものです。

次のコードでは、10進数で15を否定演算子（~）で各ビットを反転させた値を得ている。
15 は 0000_0000_0000_0000_0000_0000_0000_1111。
各ビットを反転させると1111_1111_1111_1111_1111_1111_1111_0000になり、10進数では-16 となる。

```javascript
console.log(~15); // => -16
```

### StrirngオブジェクトのindexOfメソッド

文字列（Stringオブジェクト）が持つindexOfメソッドは、
マッチする文字列を見つけて、そのインデックス（位置）を返すメソッド。
このindexOfメソッドは、検索対象が見つからない場合には-1を返す。

```javascript
const str = "森森本森森";
// 見つかった場合はインデックスを返す
// JavaScriptのインデックスは0から開始するので2を返す
console.log(str.indexOf("本")); // => 2
// 見つからない場合は-1を返す
console.log(str.indexOf("火")); // => -1
```

```javascript
const str = "森森木森森";
// indexOfメソッドは見つからなかった場合は -1 を返す
if (str.indexOf("木") !== -1) {
    console.log("木を見つけました");
}
// 否定演算子（`~`）で同じ動作を実装
// (~(-1)) は 0 となるため、見つからなかった場合はif文の中身は実行されない
if (~str.indexOf("木")) {
    console.log("木を見つけました");
}
// => "木を見つけました"
```

### Strirngオブジェクトのincludesメソッド

```javascript
const str = "森森木森森";
if (str.includes("木")) {
    console.log("木を見つけました");
}
// => "木を見つけました"
```

木を含める場合はtrueを返す。
includesメソッドは、indexOfメソッドと違い、マッチする文字列が見つかった場合にはtrueを返す。
こっちの方が使いやすそう

### 左シフト演算子（<<）・右シフト演算子（>>）

2ビット分だけ左へシフト・右へシフトする演算子
溢れたビットは捨てられる

### ゼロ埋め右シフト演算子（>>>）

異なる点としては右にあふれたビットは破棄され、0のビットを左から詰める。

このビットていつ使うのかな？と思ったので、調べてみた。  
フラグや状態管理（ビットごとに状態を持たせる）  
データ圧縮やパック・アンパック（少ないメモリで多くの情報を格納）  
効率的な乗算・除算（ビットシフトを利用）  
特定ビットの抽出や設定（ビットマスクを利用）  
数値の偶数・奇数判定（最下位ビットで判定）  
ビット演算は、低レベルでの操作やパフォーマンスが重要な場面で有効ですが、日常のプログラミングではそれほど頻繁に使われるものではありません。  
特に、組み込みシステムやパフォーマンスが求められるアルゴリズム、ゲーム開発などで多く活用されます。  
強強になるためには使いこなせるといいかもしれない。

## 代入演算子（=）

代入できる。また今までの演算子と組み合わせて使うこともできる。
`+=`、`-=`、`*=`、`/=`、`%=`、`<<=`、`>>=`、`>>>=`、`&=`、`^=`、`|=`、`**=`のように、演算した結果を代入できる。

```javascript
let num = 1;
num += 10; // num = num + 10; と同じ
console.log(num); // => 11
```

### [ES2015] 分割代入（Destructuring assignment）

分割代入は、代入演算子（=）を使うのは同じですが、左辺のオペランドが配列リテラルやオブジェクトリテラルとなる。

```javascript
const array = [1, 2];
// aには`array`の0番目の値、bには1番目の値が代入される
const [a, b] = array;
console.log(a); // => 1
console.log(b); // => 2
```

以下同文

```javascript
const array = [1, 2];
const a = array[0];
const b = array[1];
```

分割代入はオブジェクトリテラルでも使える。

```javascript
const obj = {
    "key": "value"
};
// プロパティ名`key`の値を、変数`key`として定義する
const { key } = obj;
console.log(key); // => "value"
```

以下のように簡単に書ける

```javascript
const obj = {
    "key": "value"
};
const key = obj.key;
```

## 論理演算子

論理演算子は基本的に真偽値を扱う演算子でAND（かつ）、OR（または）、NOT（否定）を表現

### AND演算子（&&）

AND演算子（&&）は、左辺の値の評価結果がtrueならば、右辺の評価結果を返す。
一方で、左辺の値の評価結果がfalseならば、そのまま左辺の値を返す。

```javascript
// 左辺はtrueであるため、右辺の評価結果を返す
console.log(true && "右辺の値"); // => "右辺の値"
// 左辺がfalseであるなら、その時点でfalseを返す
// 右辺は評価されない
console.log(false && "右辺の値"); // => false
```

and演算子は左辺を評価する際に暗黙な型変換をしてから判定する。以下はfalseを返す

- false
- undefined
- null
- 0
- 0n
- NaN
- ""（空文字列）

AND演算子はif文の条件式でよく使われるらしい確かに使いやすいかも

```javascript
const value = "str";
if (typeof value === "string" && value === "str") {
    console.log(`${value} is string value`);
}
```

### OR演算子（||）

OR演算子（||）は、左辺の値の評価結果がtrueならば、そのまま左辺の値を返す。
一方で、左辺の値の評価結果がfalseであるならば、右辺の評価結果を返す。

```javascript
// 左辺がtrueなので、左辺の値が返される
console.log(true || "右辺の値"); // => true
// 左辺がfalseなので、右辺の値が返される
console.log(false || "右辺の値"); // => "右辺の値"
```

これもf文と組み合わせて利用することが多い

### Nullish coalescing演算子

Nullish coalescing演算子(??)は、左辺の値がnullishであるならば、右辺の評価結果を返す。
nullishとは、評価結果がnullまたはundefinedとなる値

```javascript
// 左辺がnullishであるため、右辺の値の評価結果を返す
console.log(null ?? "右辺の値"); // => "右辺の値"
console.log(undefined ?? "右辺の値"); // => "右辺の値"
// 左辺がnullishではないため、左辺の値の評価結果を返す
console.log(true ?? "右辺の値"); // => true
console.log(false ?? "右辺の値"); // => false
console.log(0 ?? "右辺の値"); // => 0
console.log("文字列" ?? "右辺の値"); // => "文字列"
```

### 条件（三項）演算子（?と:）

```javascript
const valueA = true ? "A" : "B";
console.log(valueA); // => "A"
const valueB = false ? "A" : "B";
console.log(valueB); // => "B"
```

条件分岐による値を返せるため、条件によって変数の初期値が違う場合などに使われることが多い。
条件演算子の評価結果は値を返すので、constを使って宣言と同時に代入できる。

```javascript
function addPrefix(text, prefix) {
    // `prefix`が指定されていない場合は"デフォルト:"を付ける
    const pre = typeof prefix === "string" ? prefix : "デフォルト:";
    return pre + text;
}
console.log(addPrefix("文字列")); // => "デフォルト:文字列"
console.log(addPrefix("文字列", "カスタム:")); // => "カスタム:文字列"
```

if文を使った場合は、宣言と代入を分ける必要があるため、constを使うことができる。

```javascript
function addPrefix(text, prefix) {
    let pre = "デフォルト:";
    if (typeof prefix === "string") {
        pre = prefix;
    }
    return pre + text;
}

console.log(addPrefix("文字列")); // => "デフォルト:文字列"
console.log(addPrefix("文字列", "カスタム:")); // => "カスタム:文字列"
```

### グループ化演算子（(と)）

計算もそうだが、評価順序を変えるたりできて、読みにくいような式を整理するのに使える。

#### 例

```javascript
if (x || (y && z)) {
    // x が true または
    // y かつ z が true
}

if ((typeof a === "string" && typeof b === "string") || (typeof x === "number" && typeof y === "number")) {
    // `a`と`b`が文字列型 または
    // `x`と`y`が数値型
}
```