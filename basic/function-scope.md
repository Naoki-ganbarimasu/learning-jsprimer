# 関数とスコープ

定義された関数はそれぞれのスコープを持っている。スコープとは変数や関数の引数などを参照できる範囲を決めるものである。 JavaScript では、新しい関数を定義するとその関数にひもづけられた新しいスコープが作成される。関数を定義するということは処理をまとめるというだけではなく、変数が有効な範囲を決める新しいスコープを作っているといえる。

## スコープとは

スコープとは変数の名前や関数などの参照できる範囲を決めるもの。 スコープの中で定義された変数はスコープの内側でのみ参照でき、スコープの外側からは参照できない。

```js
function fn() {
  const x = 1;
  // fn関数のスコープ内から`x`は参照できる
  console.log(x); // => 1
}
fn();
// fn関数のスコープ外から`x`は参照できないためエラー
console.log(x); // => ReferenceError: x is not defined
```

変数 x は fn 関数のスコープにひもづけて定義される。 そのため、変数 x は fn 関数のスコープ内でのみ参照できる。
また関数は仮引数を持てるが、仮引数は関数のスコープにひもづけて定義される。 そのため、仮引数はその関数の中でのみ参照が可能で、関数の外からは参照できない。

```js
function fn(arg) {
  // fn関数のスコープ内から仮引数`arg`は参照できる
  console.log(arg); // => 1
}
fn(1);
// fn関数のスコープ外から`arg`は参照できないためエラー
console.log(arg); // => ReferenceError: arg is not defined
```

このような、関数によるスコープのことを関数スコープいう。

また let や const は再宣言できないが以下のようにスコープ内ならことなる場所で定義できる。

```js
// スコープ内に同じ"a"を定義すると SyntaxError となる
let a;
let a;

// 異なる関数のスコープには同じ"x"を定義できる
function fnA() {
  let x;
}
function fnB() {
  let x;
}
```

## ブロックスコープ

{と}で囲んだ範囲をブロックと呼ぶ（「文と式」の章を参照）。 ブロックもスコープを作成する。 ブロック内で宣言された変数は、スコープ内でのみ参照でき、スコープの外側からは参照できない。

```js
// ブロック内で定義した変数はスコープ内でのみ参照できる
{
  const x = 1;
  console.log(x); // => 1
}
// スコープの外から`x`を参照できないためエラー
console.log(x); // => ReferenceError: x is not defined
```

ブロックによるスコープのことをブロックスコープと呼ぶ。

if 文や while 文などもブロックスコープを作成する。 単独のブロックと同じく、ブロックの中で宣言した変数は外から参照できない。

```js
// if文のブロック内で定義した変数はブロックスコープの中でのみ参照できる
if (true) {
  const x = "inner";
  console.log(x); // => "inner"
}
console.log(x); // => ReferenceError: x is not defined
```

for 文はループごとに新しいブロックスコープを作成する。以下のコードはループごとに別々のブロックスコープが作成され、変数の宣言もそれぞれ別々のスコープで行わているためエラーが起きない。

```js
const array = [1, 2, 3, 4, 5];
// ループごとに新しいブロックスコープを作成する
for (const element of array) {
  // forのブロックスコープの中でのみ`element`を参照できる
  console.log(element);
}
// ループの外からはブロックスコープ内の変数は参照できない
console.log(element); // => ReferenceError: element is not defined
```

## スコープチェーン

関数やブロックはネスト（入れ子）して書けるが、同様にスコープもネストできる。 次のコードではブロックの中にブロックを書いている。 このとき外側のブロックスコープのことを OUTER、内側のブロックスコープのことを INNER と呼ぶ。

```js
{
  // OUTERブロックスコープ
  {
    // INNERブロックスコープ
  }
}
```

以下も同様に書くスコープ内の定義されたものが見れるがスコープ外では参照できない。

```js
{
  // OUTERブロックスコープ
  const x = "x";
  {
    // INNERブロックスコープからOUTERブロックスコープの変数を参照できる
    console.log(x); // => "x"
  }
}
```

以下はスコープ内に定義していない物を参照しようとしていてエラーを吐いている。

```js
{
  // OUTERブロックスコープ
  {
    // INNERブロックスコープ
    console.log(xyz); // => ReferenceError: xyz is not defined
  }
}
```

上記のコードは次のようなステップで参照したい変数を探索している 1. INNER ブロックスコープに変数 xyz があるかを確認 => ない 2. ひとつ外側の OUTER ブロックスコープに変数 xyz があるかを確認 => ない 3. 一番外側のスコープにも変数 xyz は定義されていない => ReferenceError が発生

内側と外側のスコープ両方に同じ名前の変数が定義されている場合もスコープチェーンの仕組みで解決できる。 次のコードでは、内側の INNER ブロックスコープと外側の OUTER ブロックスコープに同じ名前の変数 x が定義されている。 スコープチェーンの仕組みにより、現在のスコープに定義されている変数 x を優先的に参照している。

```js
{
  // OUTERブロックスコープ
  const x = "outer";
  {
    // INNERブロックスコープ
    const x = "inner";
    // 現在のスコープ(INNERブロックスコープ)にある`x`を参照する
    console.log(x); // => "inner"
  }
  // 現在のスコープ(OUTERブロックスコープ)にある`x`を参照する
  console.log(x); // => "outer"
}
```

## グローバルスコープ

プログラム直下は暗黙的なグローバルスコープ（大域スコープ）と呼ばれるスコープが存在する。 グローバルスコープとは名前のとおりもっとも外側にあるスコープで、プログラム実行時に暗黙的に作成される。

```js
// プログラム直下はグローバルスコープ
const x = "x";
console.log(x); // => "x"
```

暗黙なスコープが存在するため、以下のようにスコープ内にも呼び出せる。

```js
// グローバル変数はどのスコープからも参照できる
const globalVariable = "グローバル";
// ブロックスコープ
{
  // ブロックスコープ内には該当する変数が定義されてない -> 外側のスコープへ
  console.log(globalVariable); // => "グローバル"
}
// 関数スコープ
function fn() {
  // 関数ブロックスコープ内には該当する変数が定義されてない -> 外側のスコープへ
  console.log(globalVariable); // => "グローバル"
}
fn();
```

グローバルスコープには自分で定義したグローバル変数以外に、プログラム実行時に自動的に定義されるビルトインオブジェクトがある。

ビルトインオブジェクトには、大きく分けて 2 種類のものがある。 1 つ目は ECMAScript 仕様が定義する undefined のような変数（「undefined はリテラルではない」を参照）や isNaN のような関数、Array や RegExp などのコンストラクタ関数で、2 つ目は実行環境（ブラウザや Node.js など）が定義するオブジェクトで document や module などがある。

```js
// ビルトインオブジェクトは実行環境が自動的に定義している
// どこのスコープから参照してもReferenceErrorにはならない
console.log(isNaN); // => isNaN
console.log(Array); // => Array
```

自分で定義したグローバル変数とビルトインオブジェクトでは、グローバル変数が優先して参照される。

```js
// "Array"という名前の変数を定義
const Array = 1;
// 自分で定義した変数がビルトインオブジェクトより優先される
console.log(Array); // => 1
```

逆を言えば、ビルトインオブジェクトと同じ名前の変数を定義したことにより、ビルトインオブジェクトを参照できなくなる。むやみにグローバルスコープへ変数を定義しないことで、グローバルスコープでビルトインオブジェクトと名前が衝突するとすべてのスコープへ影響を与えるが、関数のスコープ内では影響範囲がその関数の中だけにとどまる。

## [コラム] 変数を参照できる範囲を小さくする

グローバル変数に限らず、特定の変数を参照できる範囲を小さくするのはよい。 なぜなら、現在のスコープの変数を参照するつもりがグローバル変数を参照したり、その逆も起きることがあるからである。 これを避けるシンプルな考え方は、変数はできるだけ利用するスコープ内に定義する。

```js
function doHeavyTask() {
  // 計測したい処理
}
const startTime = Date.now();
doHeavyTask();
const endTime = Date.now();
console.log(`実行時間は${endTime - startTime}ミリ秒`);
```

## 関数スコープと var の巻き上げ

`let`は`var`を改善する目的で導入された構文で、 `let`と`var`どちらも、初期値を指定せずに宣言した変数の評価結果は暗黙的に undefined となり、　`let`と`var`どちらも、変数宣言をした後に値を代入でき

```js
let let_x;
var var_x;
// 宣言後にそれぞれの変数を参照すると`undefined`となる
console.log(let_x); // => undefined
console.log(var_x); // => undefined
// 宣言後に値を代入できる
let_x = "letのx";
var_x = "varのx";
```

```js
console.log(x); // => ReferenceError: can't access lexical declaration `x' before initialization
let x = "letのx";
```

```js
V; // 解釈されたコード
// スコープの先頭に宣言部分が巻き上げられる
var x;
console.log(x); // => undefined
// 変数への代入はそのままの位置に残る
x = "varのx";
console.log(x); // => "varのx"
```

var 変数の宣言の巻き上げは、ブロックスコープを無視してもっとも近い関数またはグローバルスコープに変数をひもづける。 そのため、次のようにブロック{}で var による変数宣言を囲んでも、もっとも近い関数スコープである fn 関数の直下に宣言部分が巻き上げられる （if 文や for 文におけるブロックスコープも同様に無視される）。

```js
// 解釈されたコード
function fn() {
  // もっとも近い関数スコープの先頭に宣言部分が巻き上げられる
  var x;
  console.log(x); // => undefined
  {
    // 変数への代入はそのままの位置に残る
    x = "varのx";
  }
  console.log(x); // => "varのx"
}
fn();
```

## 関数宣言と巻き上げ

`function`キーワードを使った関数宣言も var と同様に、もっとも近い関数またはグローバルスコープの先頭に巻き上げられる。 次のコードでは、実際に hello 関数を宣言した行より前に関数を呼び出せる。

```js
// `hello`関数の宣言より前に呼び出せる
hello(); // => "Hello"

function hello() {
  return "Hello";
}
```

`function`キーワードによる関数宣言も巻き上げられるが、var による変数宣言の巻き上げとは異なり、問題となることはあまりない。実際に巻き上げられた関数を呼び出せる。

注意点として、`var` で宣言された変数へ関数を代入した場合は `var` のルールで巻き上げられる。 そのため、`var` で変数へ関数を代入する関数式では、hello 変数が巻き上げにより `undefined` となるため呼び出せません（「関数と宣言（関数式）」を参照）。

```js
// `hello`変数は巻き上げられ、暗黙的に`undefined`となる
hello(); // => TypeError: hello is not a function

// `hello`変数へ関数を代入している
var hello = function () {
  return "Hello";
};
```

## [コラム] 即時実行関数

即時実行関数は、 グローバルスコープの汚染を避けるために生まれたイディオム。

次のように、無名関数を宣言した直後に呼び出すことで、任意の処理を関数のスコープに閉じて実行できる。 関数スコープを作ることで foo 変数は無名関数の外側からはアクセスできない。

```js
// 無名関数を宣言 + 実行を同時に行っている
(function () {
  // 関数のスコープ内でfoo変数を宣言している
  var foo = "foo";
  console.log(foo); // => "foo"
})();
// foo変数のスコープ外
console.log(typeof foo === "undefined"); // => true
```

関数を式として定義して、そのまま呼び出している。 function からはじまってしまうと JavaScript エンジンが関数宣言と解釈してしまうため、無害なカッコなどで囲んで関数式として解釈させるのがよい。

```js
// 無名関数を宣言 + 実行を同時に行っている
(function () {
  // 関数のスコープ内でfoo変数を宣言している
  var foo = "foo";
  console.log(foo); // => "foo"
})();
// foo変数のスコープ外
console.log(typeof foo === "undefined"); // => true
```

## クロージャー

クロージャーとは「外側のスコープにある変数への参照を保持できる」という関数が持つ性質のこと。

```js
// `increment`関数を定義して返す関数
function createCounter() {
  let count = 0;
  // `increment`関数は`count`変数を参照
  function increment() {
    count = count + 1;
    return count;
  }
  return increment;
}
// `myCounter`は`createCounter`が返した関数を参照
const myCounter = createCounter();
myCounter(); // => 1
myCounter(); // => 2
// 新しく`newCounter`を定義する
const newCounter = createCounter();
newCounter(); // => 1
newCounter(); // => 2
// `myCounter`と`newCounter`は別々の状態を持っている
myCounter(); // => 3
newCounter(); // => 3
```

### 静的スコープ

JavaScript のスコープには、どの識別子がどの変数を参照するかが静的に決定されるという性質があるが、コードを実行する前にどの識別子がどの変数を参照しているかがわかる。
以下は printX 関数内で変数 x を参照しているが、変数 x はグローバルスコープと関数 run の中で、それぞれ定義されている。 このとき printX 関数内の x という識別子がどの変数 x を参照するかは静的に決定されている。

```js
const x = 10; // ＊1

function printX() {
  // この識別子`x`は常に ＊1 の変数`x`を参照する
  console.log(x); // => 10
}

function run() {
  const x = 20; // ＊2
  printX(); // 常に10が出力される
}

run();
```

上記は以下のような順番に参照している

1. printX の関数スコープに変数 x が定義されていない
2. ひとつ外側のスコープ（グローバルスコープ）を確認する
3. ひとつ外側のスコープに const x = 10;が定義されているので、識別子 x はこの変数を参照する。

つまり、printX 関数中に書かれた x という識別子は、run 関数の実行とは関係なく、静的に＊1 で定義された変数 x を参照することが決定される。
どの識別子がどの変数を参照しているかを静的に決定する性質を静的スコープと呼ぶ。

### [コラム] 動的スコープ

JavaScript は静的スコープであるが、動的スコープという呼び出し元により識別子がどの変数を参照するかが変わる仕組みを持つ言語もある。

```js
// 動的スコープの疑似的な言語のコード例（JavaScriptではありません）
// 変数`x`を宣言
var x = 10;

// `printX`という関数を定義
fn printX() {
    // 動的スコープの言語では、識別子`x`は呼び出し元によってどの変数`x`を参照するかが変わる
    // `print`関数でコンソールへログ出力する
    print(x);
}

fn run() {
    // 呼び出し元のスコープで、変数`x`を定義している
    var x = 20;
    printX();
}

printX(); // ここでは 10 が出力される
run(); // ここでは 20 が出力される
```

このように関数呼び出し時に呼び出し元のスコープの変数を参照する仕組みを動的スコープと呼という。
JavaScript では this という特別なキーワードだけは、呼び出し元によって動的に参照先が変わる。

## メモリ管理の仕組み

プログラミング言語は、使わなくなった変数やデータを解放する仕組みを持っている。変数や関数を定義すると定義されたデータはメモリ上に確保されるが、ハードウェアのメモリは有限だからである。 そのため、メモリからデータがあふれないように、必要なタイミングで不要なデータをメモリから解放する必要がある。

JavaScript では不要なデータをメモリから解放する際にガベージコレクションが採用されている。 ガベージコレクションとは、どこからも参照されなくなったデータを不要なデータと判断して自動的にメモリ上から解放する仕組みのことである。

```js
let x = "before text";
// 変数`x`に新しいデータを代入する
x = "after text";
// このとき"before text"というデータはどこからも参照されなくなる
// その後、ガベージコレクションによってメモリ上から解放される
```

最初にメモリ上へ確保した"before text"という文字列のデータはどこからも参照されなくなっているため、ガベージコレクションの対象となる。

関数の中で作成したデータは、その関数の実行が終了したら解放されるのでその関数が実行を終了した時点で必ずいかほうされるわけではない。

```js
unction printX() {
    const x = "X";
    console.log(x); // => "X"
}

printX();
// この時点で`"X"`を参照するものはなくなる -> 解放される
```

以下は関数で定義された変数 tempArray は返り値として、別の変数 array に代入されている。変数 tempArray が参照している配列オブジェクトは、createArray 関数の実行終了後も変数 array から参照され続けているため、そのデータが自動的に解放されるわけではない。

```js
function createArray() {
  const tempArray = [1, 2, 3];
  return tempArray;
}
const array = createArray();
console.log(array); // => [1, 2, 3]
// 変数`array`が`[1, 2, 3]`という値を参照している -> 解放されない
```

データがメモリ上から解放されるかどうかはあくまで、そのデータが参照されているかによって決定される。

## クロージャーがなぜ動くのか

- 静的スコープ: ある変数がどの値を参照するかは静的に決まる
- メモリ管理の仕組み: 参照されなくなったデータはガベージコレクションにより解放される

クロージャーとはこの２つの仕組みを利用して、関数内から特定の変数を参照し続けることで関数が状態を持てる仕組みのことをいう。

```js
const createCounter = () => {
  let count = 0;
  return function increment() {
    // `increment`関数は`createCounter`関数のスコープに定義された`変数`count`を参照している
    count = count + 1;
    return count;
  };
};
// createCounter()の実行結果は、内側で定義されていた`increment`関数
const myCounter = createCounter();
// myCounter関数の実行結果は`count`の評価結果
console.log(myCounter()); // => 1
console.log(myCounter()); // => 2
```

上記から以下のことがわかる。

- myCounter 変数は createCounter 関数の返り値である increment 関数を参照している
- myCounter 変数は increment 関数を経由して count 変数を参照している
- myCounter 変数を実行した後も count 変数への参照は保たれている

## クロージャーの用途

以下の場合で使用されることが多い。

- 関数に状態を持たせる手段として
- 外から参照できない変数を定義する手段として
- グローバル変数を減らす手段として
- 高階関数の一部分として

## [コラム] 状態を持つ関数オブジェクト

JavaScript では関数はオブジェクトの一種であり、オブジェクトであるため直接プロパティに値を代入できる。 そのため、クロージャーを使わなくても、次のように関数にプロパティとして状態を持たせることが可能である。

```js
function countUp() {
  // countプロパティを参照して変更する
  countUp.count = countUp.count + 1;
  return countUp.count;
}
// 関数オブジェクトにプロパティとして値を代入する
countUp.count = 0;
// 呼び出すごとにcountが更新される
console.log(countUp()); // => 1
console.log(countUp()); // => 2
```

関数の外から count プロパティを変更できるためこの書き方は非推奨である。 関数オブジェクトのプロパティは外からも参照でき、そのプロパティ値は変更できる。 関数の中でのみ参照可能な状態を扱いたい場合には、それを強制できるクロージャーが有効。

```js
function countUp() {
  // countプロパティを参照して変更する
  countUp.count = countUp.count + 1;
  return countUp.count;
}
countUp.count = 0;
// 呼び出すごとにcountが更新される
console.log(countUp()); // => 1
// 直接値を変更できてしまう
countUp.count = 10;
console.log(countUp()); // => 11
```
