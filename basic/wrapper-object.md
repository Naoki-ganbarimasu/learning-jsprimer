# ラッパーオブジェクト

プリミティブ型の値である文字列は String オブジェクトのインスタンスではまいが、プリミティブ型の文字列においても、String オブジェクトのインスタンスメソッドである toUpperCase メソッドを呼び出せる。

```js
// Stringの`toUpperCase`メソッドを呼び出せる
"string".toUpperCase(); // => "STRING"
```

## プリミティブ型とラッパーオブジェクト

プリミティブ型のデータのうち、`真偽値（Boolean）、数値（Number） 、BigInt、文字列（String）、シンボル（Symbol）`にはそれぞれ対応するオブジェクトが存在する。
`String`オブジェクトを new することで `String`オブジェクトのインスタンスを作れます。

```js
// "input value"の値をラップしたStringのインスタンスを生成
const str = new String("input value");
// StringのインスタンスメソッドであるtoUpperCaseを呼び出す
str.toUpperCase(); // => "INPUT VALUE"
```

このようなオブジェクトをプリミティブ型の値に対してのラッパーオブジェクトという。
以下はラッパーオブジェクトとプリミティブ型の対応である。

| ラッパーオブジェクト | プリミティブ型 | 例             |
| -------------------- | -------------- | -------------- |
| Boolean              | 真偽値         | true や false  |
| Number               | 数値           | 1 や 2         |
| BigInt               | BigInt         | 1n や 2n       |
| String               | 文字列         | "文字列"       |
| Symbol               | シンボル       | Symbol("説明") |

`undefined`と`null`に対応するラッパーオブジェクトはない。

`typeof`演算子でラッパーオブジェクトを見ると`"object"`となる。

```js
// プリミティブの文字列は"string"型
const str = "文字列";
console.log(typeof str); // => "string"
// ラッパーオブジェクトは"object"型
const stringWrapper = new String("文字列");
console.log(typeof stringWrapper); // => "object"
```

## プリミティブ型の値からラッパーオブジェクトへの自動変換

プリミティブ型の値に対してプロパティアクセスするとき、自動で対応するラッパーオブジェクトに変換される。 たとえば"string"という文字列は、自動的に new String("string")のようなラッパーオブジェクトへ変換される。 これにより、プリミティブ型の値である文字列が String のインスタンスメソッドを呼び出せるようになる。

```js
const str = "string";
// プリミティブ型の値に対してメソッド呼び出しを行う
str.toUpperCase();
// `str`へアクセスする際に"string"がラッパーオブジェクトへ変換され、
// ラッパーオブジェクトはStringのインスタンスなのでメソッドを呼び出せる
// つまり、上のコードは下のコードと同じ意味である
new String(str).toUpperCase();
```

プリミティブ型の値からラッパーオブジェクトへの変換は自動的に行われるが、明示的に作成したラッパーオブジェクトからプリミティブ型の値を取り出すこともできる。

ラッパーオブジェクト`.valueOf` メソッドを呼び出すことで、ラッパーオブジェクトから値を取り出せる。

```js
const stringWrapper = new String("文字列");
// プリミティブ型の値を取得する
console.log(stringWrapper.valueOf()); // => "文字列"
```

JavaScript には、リテラルを使ったプリミティブ型の文字列とラッパーオブジェクトを使った文字列オブジェクトがある（真偽値や数値についても同様）。 この 2 つを明示的に使い分ける利点はないため、常にリテラルを使うことを推奨されている。 理由として次の 3 つが挙げられる。

- 必要に応じて、プリミティブ型の文字列は自動的にラッパーオブジェクトに変換されるため
- `new String("string")`のようにラッパーオブジェクトのインスタンスを扱う利点がないため
- ラッパーオブジェクトを `typeof` 演算子で評価した結果が、プリミティブ型ではなく"object"となり混乱を生むため.

上記の理由から、プリミティブ型のデータからリテラル型にはリテラル型を使う。常にリテラルを使うことでラッパーオブジェクトを意識する必要がなくなった。

```js
// OK: リテラルを使う
const str = "文字列";
// NG: ラッパーオブジェクトを使う
const stringWrapper = new String("文字列");
```
